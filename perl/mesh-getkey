#!/usr/bin/perl -T
#
# Copyright (C) 2006-2017 United States Government as represented by the
# Administrator of the National Aeronautics and Space Administration
# (NASA).  All Rights Reserved.
#
# This software is distributed under the NASA Open Source Agreement
# (NOSA), version 1.3.  The NOSA has been approved by the Open Source
# Initiative.  See http://www.opensource.org/licenses/nasa1.3.php
# for the complete NOSA document.
#
# THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY WARRANTY OF ANY
# KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT
# LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL CONFORM TO
# SPECIFICATIONS, ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR
# A PARTICULAR PURPOSE, OR FREEDOM FROM INFRINGEMENT, ANY WARRANTY THAT
# THE SUBJECT SOFTWARE WILL BE ERROR FREE, OR ANY WARRANTY THAT
# DOCUMENTATION, IF PROVIDED, WILL CONFORM TO THE SUBJECT SOFTWARE. THIS
# AGREEMENT DOES NOT, IN ANY MANNER, CONSTITUTE AN ENDORSEMENT BY
# GOVERNMENT AGENCY OR ANY PRIOR RECIPIENT OF ANY RESULTS, RESULTING
# DESIGNS, HARDWARE, SOFTWARE PRODUCTS OR ANY OTHER APPLICATIONS RESULTING
# FROM USE OF THE SUBJECT SOFTWARE.  FURTHER, GOVERNMENT AGENCY DISCLAIMS
# ALL WARRANTIES AND LIABILITIES REGARDING THIRD-PARTY SOFTWARE, IF
# PRESENT IN THE ORIGINAL SOFTWARE, AND DISTRIBUTES IT "AS IS".
#
# RECIPIENT AGREES TO WAIVE ANY AND ALL CLAIMS AGAINST THE UNITED STATES
# GOVERNMENT, ITS CONTRACTORS AND SUBCONTRACTORS, AS WELL AS ANY PRIOR
# RECIPIENT.  IF RECIPIENT'S USE OF THE SUBJECT SOFTWARE RESULTS IN ANY
# LIABILITIES, DEMANDS, DAMAGES, EXPENSES OR LOSSES ARISING FROM SUCH USE,
# INCLUDING ANY DAMAGES FROM PRODUCTS BASED ON, OR RESULTING FROM,
# RECIPIENT'S USE OF THE SUBJECT SOFTWARE, RECIPIENT SHALL INDEMNIFY AND
# HOLD HARMLESS THE UNITED STATES GOVERNMENT, ITS CONTRACTORS AND
# SUBCONTRACTORS, AS WELL AS ANY PRIOR RECIPIENT, TO THE EXTENT PERMITTED
# BY LAW.  RECIPIENT'S SOLE REMEDY FOR ANY SUCH MATTER SHALL BE THE
# IMMEDIATE, UNILATERAL TERMINATION OF THIS AGREEMENT.
#

# This program outputs the public keys that are currently valid for a
# given user.

use strict;
use Getopt::Long qw(:config bundling no_ignore_case require_order);
use File::Basename;
use File::Temp;

our $VERSION = 0.37;

# default configuration
my %conf = (
    conf_file => "/etc/mesh/mesh.conf",
    prefix_dir => "/usr/local",
    var_dir => "/var/lib/mesh",
);

# parse configuration
open(FILE, $conf{conf_file}) or
    die "Config file $conf{conf_file} does not exist or is not readable\n";
my $mline;
while (my $line = <FILE>) {
    # strip whitespace and comments
    $line =~ s/^\s+|\s+$|\s*#.*//g;
    next if (!$line);
    # support line continuation operator
    $mline .= $line;
    next if ($mline =~ s/\s*\\$/ /);
    $conf{$1} = $2 if ($mline =~ /^(\S+)\s+(.*)/);
    $mline = undef;
}
close FILE;

# exit if any required parameters are not defined
foreach my $key (keys %conf) {
    die "Config parameter \"$key\" is not defined\n"
        if (!$conf{$key});
}

# untaint path
$ENV{PATH} = "/bin:/usr/bin:/usr/local/bin";
# untaint insecure environment variables
delete $ENV{$_} foreach (qw(BASH_ENV CDPATH ENV IFS));

# parse arguments
my %opts = ();
my $rc = GetOptions(\%opts,
    "local",
);
exit 1 if (!$rc || scalar(@ARGV) != 1);

# untaint user
my $user;
if ($ARGV[0] =~ /^([\w-]+)$/) {
    $user = $1;
} else {
    die "Invalid user\n";
}

# add keys generated by the user
my $meshkey = "$conf{var_dir}/meshkeys/$user";
if (-r $meshkey && $user eq (getpwuid ((stat $meshkey)[4]))) {
    # return key if exists in local directory and owned by user
    if (open(MESHKEY, "<$meshkey")) {
        print while (<MESHKEY>);
        print "\n";
        close MESHKEY;
    }
}

# add keys generated by other authorized users
if ($conf{"keygen_$user"}) {
    # read keys that have been killed by the user
    my $kill = "$conf{var_dir}/meshkeys/$user.kill";
    my %kills;
    # kill file for given user must be owned by same user
    if (-r $kill && $user eq (getpwuid ((stat $kill)[4])) &&
            open(KILL, "<$kill")) {
        while (my $print = <KILL>) {
            chomp $print;
            # record the fingerprints that were killed
            $kills{$print} = 1;
        }
        close KILL;
    }

    # return keys owned by a multi-user and not killed by the user
    foreach my $muser (split(/\s+/, $conf{"keygen_$user"})) {
        my $mkey = "$conf{var_dir}/meshkeys/$user($muser)";
        # key file for multi-user must be owned by same multi-user
        next if (! -r $mkey || $muser ne (getpwuid ((stat $mkey)[4])));
        if (open(MKEY, "<$mkey")) {
            while (my $key = <MKEY>) {
                my $tmp = File::Temp->new;
                print $tmp $key;
                close $tmp;
                # extract fingerprint from key file
                my $print = qx{ssh-keygen -l -f $tmp 2>/dev/null};
                my $print_md5 = qx{ssh-keygen -E md5 -l -f $tmp 2>/dev/null};
                # fingerprint is everything between first and second space
                $print =~ s/^\S+\s+|\s+.*$//g;
                $print_md5 =~ s/^\S+\s+|\s+.*$//g;
                next if ($kills{$print} || $kills{$print_md5});
                print $key;
            }
            close MKEY;
        }
    }
}

# exit if only local keys are requested
exit if ($opts{local});

# retrieve keys from configured remote MP/MAP
open(FILE, "<$conf{var_dir}/meshmps/$user.home") or exit;
my $home = <FILE>;
close FILE;
# home MP/MAP specifications must be in the form user@host
if ($home =~ /^([\w-]+)\@([\w-.]+)$/) {
    my ($user, $host) = ($1, $2);
    # find key suitable for accessing remote MP/MAP
    foreach my $file (glob "$conf{prefix_dir}/etc/mesh/mapkeys/*") {
        if ($file =~ /@/ && $file =~ /([[:print:]]+)/) {
            # untaint file
            $file = $1;
            # file name must be in the form user@host:port with port optional
            next if ($file !~ /\@$host(:\d+)?$/);
            $host = basename($file);
            my $port = 22;
            # extract port if given
            ($host, $port) = ($1, $2) if ($file =~ /([^:]+):(\d+)/);

            # retrieve public key from remote MP/MAP
            $meshkey = qx{ssh -q -oBatchMode=yes -i '$file' -p $port $host mesh-getkey --local $user};
            print $meshkey if ($meshkey);
            last;
        }
    }
}

